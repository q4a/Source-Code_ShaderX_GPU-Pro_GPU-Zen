//*****************************************************************************
//* This file is part of the Dimension3 renderer library                      *
//* Copyright (C) 2003  Michal Valient (valient@host.sk)                      *
//*                                                                           *
//* Dimension3 renderer can be found at http://www.dimension3.host.sk         *
//*                                                                           *
//* This program is free software; you can redistribute it and/or modify      *
//* it under the terms of the GNU General Public License as published by      *
//* the Free Software Foundation; either version 2 of the License, or         *
//* (at your option) any later version.                                       *
//*                                                                           *
//* This program is distributed in the hope that it will be useful,           *
//* but WITHOUT ANY WARRANTY; without even the implied warranty of            *
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
//* GNU General Public License for more details.                              *
//*                                                                           *
//* You should have received a copy of the GNU General Public License         *
//* along with this program; if not, write to the Free Software               *
//* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * 
//*****************************************************************************
//hdr_utility_remove_tag


//------------------------------
// Oren-Nayar lighting - Pixel shader
//
// Desc :
//   Oren-Nayar lighting and shading
//
// Part of Dimension3 Renderer
// (c)2003 Michal Valient
// akka em / STV3 akka  R.A.Y / EastW00D
//------------------------------

ps_2_0

//------------------------------
// Constant registers 
//------------------------------
//
//  c0 - roughness (R) (should be redefined in material)
def c31, 1.0f, 2.0f, 0.5f, 0.33f      //useful constants
def c30, 0.45f, 0.09f, 0.0f, 0.0f     //useful constants
def c29, 0.0f, 1.0f, 2.0f, 3.0f     //useful constants
//------------------------------
// Used input registers
//------------------------------
//
dcl         t0.xy                   //texture coordinates
dcl         t1.xyz                  //light vector
dcl         t2.xyz                  //eye vector
dcl         t3.xyzw                 //projector texture coordinates

//------------------------------
// Used input texture samplers
//------------------------------
//
dcl_2d      s0                      //diffuse texture (gloss in alpha)
dcl_2d      s1                      //normal texture
dcl_2d      s2                      //look-up
dcl_2d      s3                      //spotlight texture

//------------------------------
// Output
//------------------------------
//
// oC0 - output color

//#########################################################################
//##   CODE    ############################################################
//#########################################################################
//

//------------------------------
// Load and normalize input vectors
//------------------------------
//
texld       r0, t0, s1              //load normal
mad         r1, r0, c31.g, -c31.r   //bias normal to range -1,1
nrm         r11, r1                 //r11 = normalized normal
mov         r1.xyz, t1
nrm         r10, r1                 //r10 = normalized light vector
mov         r1.xyz, t2
nrm         r9, r1                  //r9 = normalized eye vector

//------------------------------
// A = 1 - 0.5 * R^2 / (R^2 + 0.33)
//------------------------------
//
mul         r0, c0.r, c0.r          //R^2
add         r1, r0, c31.a           //R^2 + 0.33
rcp         r1, r1.r                //1 / (R^2 + 0.33)
mul         r0, r1.r, r0            //R^2 / (R^2 + 0.33)
mad         r8, r0.r, -c31.b, c31.r //1 - 0.5 * R^2 / (R^2 + 0.33)

//------------------------------
// B = 0.45 * R^2 / (R^2 + 0.09)
//------------------------------
//
mul         r0, c0.r, c0.r          //R^2
add         r1, r0, c30.g           //R^2 + 0.09
rcp         r1, r1.r                //1 / (R^2 + 0.09)
mul         r0, r1.r, r0            //R^2 / (R^2 + 0.09)
mul         r7, r0.r, c30.r         //r8 = 0.45 * R^2 / (R^2 + 0.09)

//------------------------------
// CX = Max(0, cos (l',v'))
//------------------------------
//
dp3         r1, r10, r11            //these four instructions are projecting
mul         r1, r11, r1             //light vector to plane defined by T and B
sub         r1, r10, r1             //equation is : l' = normalize(l - n * (n.l))
nrm         r0, r1                  //in our case r0 = normalize(r10 - r9 * r1)

dp3         r2, r9, r11             //these four instructions are projecting
mul         r2, r11, r2             //eye vector to plane defined by T and B
sub         r2, r9, r2              //equation is : v' = normalize(v - n * (n.v))
nrm         r1, r2                  //in our case r1 = normalize(r11 - r9 * r2)

dp3         r6, r0, r1              //(l'.v') = (r0.r1)
max         r6, r6, c29.r           //only positive values

//------------------------------
// DX = texture lookup for sin(a)*tan(b); a=max(O-r,O-i); b=min(O-r,O-i)
//------------------------------
//
dp3         r1.x, r10, r11          //n.l
dp3         r1.y, r9, r11           //n.v
texld       r0, r1, s2              //look up
mov         r5, r0.r

//------------------------------
// completize it - A + B*CX*DX
//------------------------------
//
mul         r0, r5, r6              //CX*DX
mul         r0, r0, r7              //B*CX*DX
add         r4, r0, r8              //A + B*CX*DX

//------------------------------
// Load texture, compute diffuse part and combine it all to output
//------------------------------
//
dp3_sat     r1, r11, r10            //n.l
mul         r1, r1, r4              //modulate by A + B*CX*DX
texld       r0, t0, s0              //load diffuse and specular texture
mul         r0, r0, r1              //compute diffuse texture
texldp      r4, t3, s3              //load projector texture (perspective correct)
mul         r0, r0, r4
mov         oC0, r0
