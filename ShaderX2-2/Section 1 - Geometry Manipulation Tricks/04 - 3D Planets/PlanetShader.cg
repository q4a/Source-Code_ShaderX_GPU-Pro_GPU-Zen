struct Vert
{
    float4 pos  : POSITION;
    float4 dif  : COLOR0;
    float4 tex  : TEXCOORD0;
};
struct VertOut
{
    float4 pos  : POSITION;
    float4 dif  : COLOR0;
    float4 tex  : TEXCOORD0;
	float4 tex1  : TEXCOORD1;
	float3 tex2  : TEXCOORD2;
};
float3 s_curve(float3 v)
{
    return v * v * (3 - 2 * v);
}

#define B  49      // table size
#define B2 100      // B*2 + 2
#define BR 0.020408163265306122448979591836735 // 1 / B

// 3D version
float noise(float3 v, float4 pg[B2])
{
  v = v + float3(10000.0f, 10000.0f, 10000.0f);   // hack to avoid negative numbers

  float3 i = frac(v * BR) * B;   // index between 0 and B-1
  float3 f = frac(v);            // fractional position

  // lookup in permutation table
  float2 p;
  p[0] = pg[ i[0]     ].w;
  p[1] = pg[ i[0] + 1 ].w;
  p = p + i[1];

  float4 b;
  b[0] = pg[ p[0] ].w;
  b[1] = pg[ p[1] ].w;
  b[2] = pg[ p[0] + 1 ].w;
  b[3] = pg[ p[1] + 1 ].w;
  b = b + i[2];

  // compute dot products between gradients and vectors
  float4 r;
  r[0] = dot( pg[ b[0] ].xyz, f );
  r[1] = dot( pg[ b[1] ].xyz, f - float3(1.0f, 0.0f, 0.0f) );
  r[2] = dot( pg[ b[2] ].xyz, f - float3(0.0f, 1.0f, 0.0f) );
  r[3] = dot( pg[ b[3] ].xyz, f - float3(1.0f, 1.0f, 0.0f) );

  float4 r1;
  r1[0] = dot( pg[ b[0] + 1 ].xyz, f - float3(0.0f, 0.0f, 1.0f) );
  r1[1] = dot( pg[ b[1] + 1 ].xyz, f - float3(1.0f, 0.0f, 1.0f) );
  r1[2] = dot( pg[ b[2] + 1 ].xyz, f - float3(0.0f, 1.0f, 1.0f) );
  r1[3] = dot( pg[ b[3] + 1 ].xyz, f - float3(1.0f, 1.0f, 1.0f) );

  // interpolate
  f = s_curve(f);
  r = lerp( r, r1, f[2] );
  r = lerp( r.xyyy, r.zwww, f[1] );
  return lerp( r.x, r.y, f[0] );
}
float MultiFractal(float3 pos, float octaves, float offset,float freqchange,float h,float4 pg[B2])
{
	float result;
	float signal;
	float weight;
	float freq=1;
	result=(noise(pos,pg)+offset)*pow(freq,-h);
	freq*=freqchange;
	weight=result;
	pos*=freqchange;
	for(int i=0;i<octaves;i++)
	{
		clamp(weight,0,1);//Clamp used to get rid of a conditional
		signal=(noise(pos,pg)+offset)*pow(freq,-h);
		freq*=freqchange;
		result+=weight*signal;
		weight*=signal;
		pos*=freqchange;
		i++;

	}
return result;
}
VertOut main(const Vert In, const uniform float4x4 ModelViewProj,const uniform float NumberOfPoints, const uniform float4 RandomArray[B2],const uniform float3 light )
{
    VertOut Out;
	float4 Sphere=In.pos;
	float4 SphereTex=In.tex;
	float fxsin;
	float fxcos;
	float fysin;
	float fycos;
	sincos(In.pos.x,fxsin,fxcos);
	sincos(In.pos.y,fysin,fycos);
	Sphere.x=fysin*fxsin;
	Sphere.y=fysin*fxcos;
	Sphere.z=fycos;
	float modify=((MultiFractal(Sphere.xyz,5,.8,2,.15,RandomArray)/15)+1);
	Sphere.xyz*=modify*1.5;
	SphereTex.x=SphereTex.x/(NumberOfPoints);
    SphereTex.y=(2*SphereTex.y)/(NumberOfPoints);
	float4 OutPos=mul(Sphere, ModelViewProj);
	Out.pos = OutPos;
	Out.dif.x=2*(modify-.9);
    Out.tex= SphereTex;
	float4 normal=OutPos;
	Out.tex1=normal;
    Out.tex2=normalize(light - OutPos.xyz);
	return Out;
}
