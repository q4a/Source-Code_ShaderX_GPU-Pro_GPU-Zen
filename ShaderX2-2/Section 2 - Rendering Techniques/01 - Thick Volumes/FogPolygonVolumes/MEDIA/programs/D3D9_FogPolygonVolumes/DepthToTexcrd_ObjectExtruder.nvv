/*********************************************************************NVMH4****
Path:  SDK\MEDIA\programs\D3D9_FogPolygonVolumes
File:  DepthToTexcrd_ObjectExtruder.nvv

Copyright NVIDIA Corporation 2002
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.



Comments:

Also outputs oT3 texture coordinate for projecting texture to exactly
cover the screen



Requires:
CV_CONSTS_1 = 0.0, 0.5, 1.0, 2.0


******************************************************************************/


#include "Constants.h"


#define V_POSITION  v0
#define V_NORMAL    v1
#define V_DIFFUSE   v2
#define V_TEXTURE   v3


#define VEC_VERT_TO_EYE      r0
#define VEC_VERT_TO_LIGHT    r1

#define ALIGNED       r2

#define EYE_LOCAL     r3
#define EYE_VECTOR    r5

#define TEMP          r6
#define COR_NORMAL    r7



vs.1.1

dcl_position	v0
dcl_normal		v1
dcl_texcoord	v3
dcl_color		v2


//////////////////////////////////////////////
// no fogging
// fog = 1.0 = no fog

//@mov oFog.x, c[CV_CONSTS_1].z
mov oFog, c[CV_CONSTS_1].z
mov oD1, c[CV_CONSTS_1].xxx


//////////////////////////////////////////////
// Normalize vector from vertex to the light:

add  VEC_VERT_TO_LIGHT, -c[CV_LIGHT_POS_OSPACE], V_POSITION
dp3 TEMP.w, VEC_VERT_TO_LIGHT, VEC_VERT_TO_LIGHT
rsq TEMP.w, TEMP.w		
mul VEC_VERT_TO_LIGHT, VEC_VERT_TO_LIGHT, TEMP.w



// N dot L for diffuse component
// Point light is not attenuated

dp3 r4, VEC_VERT_TO_LIGHT, -V_NORMAL


//////////////////////////////////////////////////////////
// Inset the position along the normal vector direction
// This moves the shadow volume points inside the model
//  slightly to minimize poping of shadowed areas as
//  each facet comes in and out of shadow.
// CV_FATNESS_SCALE should be negative

mul r7, V_NORMAL, c[CV_FATNESS_SCALE]
add r7, V_POSITION, r7
mov r7.w, V_POSITION.w


//////////////////////////////////////////////////////////
// scale the vector from light to vertex by 
//  the shadow distance

mul r3, VEC_VERT_TO_LIGHT, c[CV_EXTRUSION_DIST]


// If r4 < 0 then vertex faces away from light, so 
//  move it along the direction to the light to extrude the
//  shadow volume.
// We coudl compare against 0 in c[CV_CONSTS_1].xxxx, but 
//  instead we use a small threshold value held in a 
//  separate constant

slt  r5, r4,  c[CV_NDOTLTHRESH].xxxx	// r5 = N dot L < 0
										// If r5 true, then we extrude
									
///////////////////////////////////////
// extrude back-facing shadow volume points 

mad r2, r3, r5, r7				// r7 = position inset along normal
								// r7 ~ V_POSITION

////////////////////////////
// transform to hclip space

dp4 r1.x, r2, c[CV_WORLDVIEWPROJ_0]
dp4 r1.y, r2, c[CV_WORLDVIEWPROJ_1]
dp4 r1.z, r2, c[CV_WORLDVIEWPROJ_2]
dp4 r1.w, r2, c[CV_WORLDVIEWPROJ_3]


mov oPos, r1


//////////////////////////////////////////////
// Generate texture coordinates according to 
//  z depth of the object (before w divide, so
//  z intervals are regular & linear).
//
// Texture coordinates address ramp textures with
//  1st coordinate addressing 2D ramp for red & green
//  and 2nd coordinate addressing 1D ramp for blue.
// This encodes depth as an RGB value.
//
// red =	tex coord 0 .x = high bits
// green =	tex coord 0 .y = mid bits
// blue =	tex coord 1    = low bits


// Grab depth from r1.z
// r1.xy must not be zero for the dither coordinate generation option


// Scale the depth value so the appropriate number of
//  color ramps are mapped to the interval.

mul r6, r1.zzzz, c[CV_RAMPSCALE].xxxx
	// mask off all but X coordinate and write 1 to z and w
mad oT0.xzw, r6, c[CV_CONSTS_1].zxxx, c[CV_CONSTS_1].xxzz


// Green forms the middle precision bits of the depth value
// For green, multiply depth value by a scale factor which
//  affects how many green bands of color will repeat per
//  red band.
// For example, if red and green values from 0 to 32 are used
//  in each color ramp, then the green ramp should repeat 32
//  times as much as the red ramp, which is one full green ramp
//  per increment of red color.

mul oT0.y, r1.zzzz, c[CV_RAMPSCALE].yyyy


// The same is done for the last texture coordinate, which will
//  be used to generate the blue ramps.  Blue should complete
//  one full ramp for every increment of green.

mul r6, r1.zzzz, c[CV_RAMPSCALE].zzzz


// Calculate y coordinate based on dither control constant
//  to enable or disable dithering.
// The y=0 line of the blue texture has no dithering, so setting y
//  coordinate to zero will disable the dithering

dp3 r6.y, r1, c[CV_DITHER_CONTROL]	// set CV_DITHER_CONTROL to 0,0,0,0 for no dither




//  r6 * (1,1,0,0) + (0,0,1,1)
mad oT1, r6, c[CV_CONSTS_1].zzxx, c[CV_CONSTS_1].xxzz




/////////////////////////////////////////////////////
// Texture coords for projecting texture to exactly 
//  cover the screen.  Converts geometry screen
//  position to a texture coordinate from [0,1]
// Uses half-texel width and height offset to sample
//  from texel center, not upper-left corner of texels
//  OpenGL does not require this half-texel offset.
//
// Turn screen space position into texture coordinate
// Bias position from [-1,1] to [0,1] range by
//   multiplying x,y by 0.5*w and add 0.5*w
//   This is equivalent to (x+1)/2, (y+1)/2, etc.
//
// Use with D3DTTFF_PROJECTED | D3DTTFF_COUNT4
//

// Multiply by 0.5
mul r1.xy, r1.xy, c[CV_CONSTS_1].yyyy

// Add w/2 to x,y to shift from (x/w,y/w) in the 
//  range [-1/2,1/2] to (x/w,y/w) in the range [0,1]

mad r1.xy, r1.wwww, c[CV_CONSTS_1].yyyy, r1.xy

// Invert y coordinate by setting y = 1-y
// But remeber, w!=1 so 1.0 really equals 1*w
// y = 1*w - y

add r1.y, r1.w, -r1.y


// Add half-texel offset to sample from texel centers, 
//  not texel corners
// Multiply by w because w != 1

mad r1.xy, r1.wwww, c[CV_HALF_TEXEL_SIZE], r1.xy


mov oT3, r1

